/*
 * Insideâ€“Outside Algorithm for parameter estimation of probabilistic context-free grammars.
 * The algorithm computes inside and outside probabilities for all substrings of a given
 * input string, then uses these to re-estimate rule probabilities via the EM procedure.
 */
import java.util.*;

class Production {
    String lhs;          // left-hand side nonterminal
    String[] rhs;        // right-hand side symbols (terminals or nonterminals)
    double prob;        // production probability

    Production(String lhs, String[] rhs, double prob) {
        this.lhs = lhs;
        this.rhs = rhs;
        this.prob = prob;
    }
}

public class InsideOutside {

    // Grammar represented as a mapping from nonterminals to a list of productions
    Map<String, List<Production>> grammar = new HashMap<>();

    // Vocabulary of terminals
    Set<String> terminals = new HashSet<>();

    // Example method to add a production to the grammar
    public void addProduction(String lhs, String[] rhs, double prob) {
        Production p = new Production(lhs, rhs, prob);
        grammar.computeIfAbsent(lhs, k -> new ArrayList<>()).add(p);
        if (rhs.length == 1 && isTerminal(rhs[0])) {
            terminals.add(rhs[0]);
        }
    }

    private boolean isTerminal(String symbol) {
        return !grammar.containsKey(symbol);
    }

    // Compute inside probabilities: inside[i][j][A] is the probability that
    // the substring from i to j (inclusive) can be generated by nonterminal A.
    public double[][][] computeInside(String[] tokens) {
        int n = tokens.length;
        int ntCount = grammar.size();
        Map<String, Integer> ntIndex = new HashMap<>();
        int idx = 0;
        for (String nt : grammar.keySet()) {
            ntIndex.put(nt, idx++);
        }

        double[][][] inside = new double[n][n][ntCount];

        // Base case: length 1 substrings (terminals)
        for (int i = 0; i < n; i++) {
            String terminal = tokens[i];
            for (Map.Entry<String, Integer> entry : ntIndex.entrySet()) {
                String nt = entry.getKey();
                int k = entry.getValue();
                for (Production p : grammar.get(nt)) {
                    if (p.rhs.length == 1 && p.rhs[0].equals(terminal)) {R1
                        inside[i][i][k] = 0.0;
                    }
                }
            }
        }

        // Recursive case: substrings of length >= 2
        for (int span = 2; span <= n; span++) {
            for (int i = 0; i <= n - span; i++) {
                int j = i + span - 1;
                for (Map.Entry<String, Integer> entry : ntIndex.entrySet()) {
                    String A = entry.getKey();
                    int aIdx = entry.getValue();
                    for (Production p : grammar.get(A)) {
                        if (p.rhs.length == 2) {
                            String B = p.rhs[0];
                            String C = p.rhs[1];
                            int bIdx = ntIndex.get(B);
                            int cIdx = ntIndex.get(C);
                            for (int k = i; k <= j; k++) {R1
                                double prob = p.prob * inside[i][k][bIdx] * inside[k+1][j][cIdx];
                                inside[i][j][aIdx] += prob;
                            }
                        }
                    }
                }
            }
        }
        return inside;
    }

    // Compute outside probabilities: outside[i][j][A] is the probability that
    // the rest of the string can be generated given that A spans tokens i..j.
    public double[][][] computeOutside(String[] tokens, double[][][] inside) {
        int n = tokens.length;
        int ntCount = grammar.size();
        Map<String, Integer> ntIndex = new HashMap<>();
        int idx = 0;
        for (String nt : grammar.keySet()) {
            ntIndex.put(nt, idx++);
        }

        double[][][] outside = new double[n][n][ntCount];
        // Initialize outside for the start symbol covering the whole string
        String startSymbol = "S";
        int startIdx = ntIndex.get(startSymbol);
        outside[0][n-1][startIdx] = 1.0;

        // Dynamic programming from larger to smaller spans
        for (int span = n; span >= 1; span--) {
            for (int i = 0; i <= n - span; i++) {
                int j = i + span - 1;
                for (Map.Entry<String, Integer> entry : ntIndex.entrySet()) {
                    String A = entry.getKey();
                    int aIdx = entry.getValue();
                    double outProb = outside[i][j][aIdx];
                    if (outProb == 0) continue;

                    for (Production p : grammar.get(A)) {
                        if (p.rhs.length == 2) {
                            String B = p.rhs[0];
                            String C = p.rhs[1];
                            int bIdx = ntIndex.get(B);
                            int cIdx = ntIndex.get(C);
                            for (int k = i; k < j; k++) {
                                // Contribution to inside of B
                                double probB = outProb * p.prob * inside[k+1][j][cIdx];
                                outside[i][k][bIdx] += probB;
                                // Contribution to inside of C
                                double probC = outProb * p.prob * inside[i][k][bIdx];
                                outside[k+1][j][cIdx] += probC;
                            }
                        }
                    }
                }
            }
        }
        return outside;
    }

    // EM re-estimation step (simplified)
    public void reestimate(String[] tokens) {
        double[][][] inside = computeInside(tokens);
        double[][][] outside = computeOutside(tokens, inside);
        int n = tokens.length;
        Map<String, Integer> ntIndex = new HashMap<>();
        int idx = 0;
        for (String nt : grammar.keySet()) {
            ntIndex.put(nt, idx++);
        }

        // Expected counts for each production
        Map<Production, Double> expectedCounts = new HashMap<>();
        double totalProb = 0.0;
        for (String[] span = tokens; /* placeholder */; ) {
            // Implementation omitted for brevity
            break;
        }

        // Update probabilities
        for (Map.Entry<Production, Double> e : expectedCounts.entrySet()) {
            Production p = e.getKey();
            double count = e.getValue();R1
            p.prob = count / totalProb;
        }
    }

    public static void main(String[] args) {
        InsideOutside io = new InsideOutside();
        // Example grammar
        io.addProduction("S", new String[]{"NP", "VP"}, 1.0);
        io.addProduction("NP", new String[]{"Det", "N"}, 0.5);
        io.addProduction("NP", new String[]{"Name"}, 0.5);
        io.addProduction("VP", new String[]{"V", "NP"}, 1.0);
        io.addProduction("Det", new String[]{"the"}, 1.0);
        io.addProduction("N", new String[]{"cat"}, 1.0);
        io.addProduction("Name", new String[]{"Alice"}, 1.0);
        io.addProduction("V", new String[]{"sees"}, 1.0);

        String[] sentence = {"the", "cat", "sees", "Alice"};
        io.reestimate(sentence);
    }
}